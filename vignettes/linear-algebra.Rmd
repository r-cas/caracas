---
title: "Linear algebra in `caracas`"
author: Mikkel Meyer Andersen and Søren Højsgaard
date: "`r date()`"
output: 
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 3
    number_sections: true
vignette: >
  %\VignetteIndexEntry{Linear algebra in `caracas`}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction

```{r, message=FALSE, echo=FALSE}
library(caracas)
##packageVersion("caracas")
```

```{r, include = FALSE}
inline_code <- function(x) {
  x
}

if (!has_sympy()) {
  # SymPy not available, so the chunks shall not be evaluated
  knitr::opts_chunk$set(eval = FALSE)
  
  inline_code <- inline_code <- function(x) {
    deparse(substitute(x))
  }
}
```

This vignette is based on `caracas` version `r packageVersion("caracas")`. `caracas` is avavailable on CRAN at [https://cran.r-project.org/package=caracas] and on github at
[https://github.com/r-cas/caracas].

# Elementary matrix operations



## Creating matrices / vectors

```{r}
A <- matrix(c("a", "b", "0", "1"), 2, 2) %>% as_sym()
A

A2 <- matrix(c("a", "b", "c", "1"), 2, 2) %>% as_sym()
A2

B <- matrix(c("a", "b", "0", 
              "c", "c", "a"), 2, 3) %>% as_sym()
B

b <- matrix(c("b1", "b2"), nrow = 2) %>% as_sym()
```

Note that a vector is a matrix in which one of the dimensions is one. 


## Addition / multiplication of matrices / vectors

## Matrix-matrix sum and product; 

```{r}
A + A2
A %*% B
```

## Hadamard (elementwise) product

```{r}
A * A2 
```

## Matrix inverse; solve system of linear equations

Solve $Ax=b$ for $x$:

```{r}
inv(A)
x <- solve_lin(A, b)
x
A %*% x ## Sanity check
```

## Generalized inverse; left and right inverse [TBW]



# More special linear algebra functionality

Below we present convience functions for performing linear algebra operations. 
If you need a function in SymPy for which we have not supplied a convinience function (see <https://docs.sympy.org/latest/modules/matrices/matrices.html>), 
you can 
still call it with the `do_la()` function presented at the end of this section.

## QR decomposition

```{r}
A <- matrix(c("a", "0", "0", "1"), 2, 2) %>% as_sym()
A
qr_res <- QRdecomposition(A)
qr_res$Q
qr_res$R
```

## Eigenvalues and eigenvectors

```{r}
eigenval(A)
```

```{r}
evec <- eigenvec(A)
evec
evec1 <- evec[[1]]$eigvec
evec1
simplify(evec1)

lapply(evec, function(l) simplify(l$eigvec))
```


## Inverse

```{r}
inv(A)
```


## Additional

`do_la` short for "do linear algebra"

```{r}
args(do_la)
```

The above functions can be called:

```{r}
do_la(A, "QRdecomposition") # == QRdecomposition(A)
do_la(A, "inv") # == inv(A)
do_la(A, "eigenvec") # == eigenvec(A)
do_la(A, "eigenvals") #  == eigenval(A)
```


### Characteristic polynomium

```{r}
p <- do_la(A, "charpoly")
p
as_expr(p)
```

### Rank

```{r}
do_la(A, "rank")
```

### Cofactor

```{r}
do_la(A, "cofactor", 0, 1)
do_la(A, "cofactor_matrix")
```

### Echelon form

```{r}
do_la(A, "echelon_form")
```

### Cholesky factorisation

```{r}
B <- as_sym("[[9, 3*I], [-3*I, 5]]")
B
do_la(B, "cholesky")
```

### Gram Schmidt

```{r}
B <- t(as_sym("[[ 2, 3, 5 ], [3, 6, 2], [8, 3, 6]]"))
do_la(B, "GramSchmidt")
```


### Reduced row-echelon form (rref)

```{r}
B_rref <- do_la(B, "rref")
B_rref
```


